language: python

################################################################################
python:
  # We don't actually use the Travis Python, but this keeps it organized.
  - "2.7"
  - "3.4"

################################################################################
# Setup the environment before installing
before_install:
  - sudo apt-get update
  # ----------------------------------------------------------------------------
  # The following is taken/adapted from Minicoda's how-to Travis page
  # http://conda.pydata.org/docs/travis.html
  # ----------------------------------------------------------------------------
  # We do this conditionally because it saves us some downloading if the
  # version is the same.
  - if [[ "$TRAVIS_PYTHON_VERSION" == "2.7" ]]; then
      wget https://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh -O miniconda.sh;
    else
      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;
    fi
  - bash miniconda.sh -b -p $HOME/miniconda
  - export PATH="$HOME/miniconda/bin:$PATH"
  - hash -r
  # Automatically say yes to any check from conda
  - conda config --set always_yes yes --set changeps1 no
  - conda update -q conda
  # Useful for debugging any issues with conda
  - conda info -a
  # Create the conda environment with pip as the only dependency installed
  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION pip
  # Activate the test environment
  - source activate test-environment
  # ----------------------------------------------------------------------------
  # Define a helper function which installs dependencies from a list in a file,
  # which uses conda where it can and pip when it can't.
  #
  # First, we remove the version requirement and get just the package name.
  # Then we search the conda database to see if a package with this exact name
  # is present. We already updated our cache, so we don't need to ask the
  # server again, and just use the cached copy. The output of this is a
  # header line and then a list of matching package names. We then grep
  # this to check whether one of the lines of the output is an exact match
  # for the name of the package we want to install.
  - function conda_or_pip_install_file {
        while read PV; do
          echo "";
          echo "==================================================================";
          PN="$(echo $PV | sed 's/^\([^=<>]*\).*/\1/')";
          if echo "$PV" | grep -qEv '^-e' &&
            conda search $PN --full-name --use-index-cache --names-only |
              grep -qFxi $PN;
          then
            echo "Package $PN is on conda. Installing it from there.";
            echo "------------------------------------------------------------------";
            conda install -q $PV;
          else
            echo "Package $PN isn't on conda. Trying to install it from PyPI.";
            echo "------------------------------------------------------------------";
            pip install $PV;
          fi;
          if [[ $? -ne 0 ]]; then return 1; fi;
        done < $1;
    }

################################################################################
install:
  # Install required packages listed in requirements.txt. Use conda if they are
  # on there, and pip if they aren't. It is much faster to install from conda
  # because the packages are pre-compiled, but not everything is there.
  - if [ -f requirements.txt ]; then
      conda_or_pip_install_file requirements.txt;
    fi;
  # ----------------------------------------------------------------------------
  # Now install your own package, e.g.
  # - python setup.py install

################################################################################
before_script:
  # Double-check we are still in the right directory
  - pwd
  # Check what python packages we have installed
  - pip freeze
  # ----------------------------------------------------------------------------
  # Set up folders for test results
  - if [ "$SHIPPABLE" = "true" ]; then
      mkdir -p shippable/testresults;
      mkdir -p shippable/codecoverage;
    fi;

################################################################################
script:
  - which python
  - pip freeze
  # ----------------------------------------------------------------------------
  # Your test script goes here, e.g.
  # - python setup.py test
  # - py.test --junitxml=testresults.xml --cov=PACKAGE_DIRECTORY --cov-report xml --cov-config .coveragerc

################################################################################
after_script:
  # Check where we ended up and what's going on where we are
  - pwd
  - ls -alh
  # ----------------------------------------------------------------------------
  # Move results and coverage files into appropriate places
  - if [ "$SHIPPABLE" = "true" ] && [ -f testresults.xml ]; then
      mv testresults.xml shippable/testresults/;
    fi;
  - if [ "$SHIPPABLE" = "true" ] && [ -f coverage.xml ]; then
      mv coverage.xml shippable/codecoverage/;
    fi;
